<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Складская логистика</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
      :root {
        --primary: #4a76a8;
        --secondary: #5bc0de;
        --success: #5cb85c;
        --danger: #d9534f;
        --warning: #f0ad4e;
        --dark: #2c3e50;
        --light: #f8f9fa;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f5f5f5;
        color: #333;
        overflow-x: hidden;
        touch-action: manipulation;
      }

      .container {
        max-width: 100%;
        padding: 10px;
        position: relative;
      }

      .panel {
        background-color: white;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 10px;
        color: var(--dark);
      }

      /* Экран приемки заказов */
      .reception {
        position: relative;
        height: 180px;
        width: 100%; /* Добавляем явное указание ширины */
        min-width: 800px; /* Минимальная ширина для 5 клиентов */
        background-color: #e9f5ff;
        border-radius: 10px;
        overflow-x: auto; /* Добавляем горизонтальную прокрутку если нужно */
        overflow-y: hidden;
        margin-bottom: 15px;
      }

      .client-queue {
        position: relative;
        height: 100%;
        width: 100%;
      }

      .client-container {
        position: absolute;
        bottom: 0;
        width: 70px;
        margin-right: 10px;
        height: 120px;
      }

      @media (max-width: 768px) {
        .reception {
          min-width: 500px;
        }
        .client-container {
          width: 60px;
        }
      }

      .patience-meter {
        position: absolute;
        top: 0;
        left: 15px;
        width: 50px;
        height: 5px;
        background-color: #e0e0e0;
        border-radius: 3px;
        overflow: hidden;
      }

      .client {
        position: absolute;
        bottom: 0;
        width: 50px;
        height: 90px;
        background-repeat: no-repeat;
        background-position: center bottom;
        background-size: 40px;
        transition: all 0.5s;
      }

      .order-info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background-color: white;
        padding: 3px 6px;
        border-radius: 3px;
        font-size: 11px;
        white-space: nowrap;
        z-index: 1;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      .client.neutral {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%232c3e50"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>');
      }

      .client.happy {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%232c3e50"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/><circle cx="8.5" cy="10.5" r="1.5"/><circle cx="15.5" cy="10.5" r="1.5"/></svg>');
        animation: happyJump 0.5s;
      }

      .client.angry {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%232c3e50"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="8.5" cy="10.5" r="1.5"/><circle cx="15.5" cy="10.5" r="1.5"/><path d="M12 17c2.28 0 4.22-1.66 5-4H7c.78 2.34 2.72 4 5 4z"/></svg>');
        animation: shake 0.5s;
      }

      @keyframes happyJump {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      .patience-progress {
        height: 100%;
        background-color: #5cb85c;
        width: 100%;
        transition: width 1s linear;
      }

      /* Склад */
      .warehouse-container {
        overflow-x: auto;
        margin-bottom: 15px;
      }

      .warehouse {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 5px;
        width: max-content;
        min-width: 100%;
      }

      .shelf {
        aspect-ratio: 1;
        background-color: #f1f1f1;
        border: 1px dashed #ccc;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 5px;
        position: relative;
        overflow: hidden;
        min-width: 50px;
      }

      .delivery-slot {
        height: 60px;
        background-color: #e9f5ff;
        border: 2px dashed var(--primary);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 5px;
        margin-bottom: 10px;
        position: relative;
      }

      .delivery-label {
        position: absolute;
        top: -20px;
        font-size: 12px;
        color: var(--primary);
      }

      .delivery-slot.active {
        background-color: #d4edda;
        border: 2px solid var(--success);
      }

      .package {
        width: 80%;
        height: 80%;
        background-size: cover;
        background-position: center;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 12px;
        cursor: grab;
        user-select: none;
        position: relative;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s, box-shadow 0.2s;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .package.beige {
        background-color: #f5e6d3;
      }
      .package.brown {
        background-color: #8b4513;
      }
      .package.gray {
        background-color: #a9a9a9;
      }
      .package.purple {
        background-color: #9370db;
      }

      .package.active {
        transform: scale(1.1);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        z-index: 10;
        background-color: var(--warning);
      }

      /* Статистика */
      .stats {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        position: sticky;
        top: 0;
        background-color: #f5f5f5;
        padding: 10px;
        z-index: 50;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .stat-item {
        text-align: center;
        flex: 1;
      }

      .stat-value {
        font-size: 18px;
        font-weight: bold;
        color: var(--primary);
      }

      .stat-label {
        font-size: 12px;
        color: #666;
      }

      /* Инструкция */
      .help-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: var(--primary);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        cursor: pointer;
        z-index: 100;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        max-width: 90%;
        max-height: 80%;
        overflow-y: auto;
      }

      .modal-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 10px;
        color: var(--dark);
      }

      .close-btn {
        float: right;
        cursor: pointer;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="stats">
        <div class="stat-item">
          <div class="stat-value" id="score">0</div>
          <div class="stat-label">Очки</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="time">60</div>
          <div class="stat-label">Секунд</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="level">1</div>
          <div class="stat-label">Уровень</div>
        </div>
      </div>
      <!-- Кнопка помощи -->
      <div class="help-btn" id="helpBtn">?</div>

      <!-- Модальное окно с инструкцией -->
      <div class="modal" id="helpModal">
        <div class="modal-content">
          <span class="close-btn" id="closeHelpBtn">&times;</span>
          <div class="modal-title">Как играть</div>
          <p>
            1. Клиенты приходят с заказами (номер заказа отображается над
            клиентом).
          </p>
          <p>
            2. Найдите нужную коробку на складе и перетащите ее в зону выдачи.
          </p>
          <p>3. Коробка подсвечивается оранжевым, когда вы ее берете.</p>
          <p>
            4. Зона выдачи подсвечивается зеленым, когда коробка находится над
            ней.
          </p>
          <p>5. Отпустите коробку в зоне выдачи, чтобы выполнить заказ.</p>
          <p>6. Клиент уйдет, если вы не успеете обработать заказ вовремя.</p>
          <p>
            7. Получайте очки за правильные заказы и переходите на новые уровни!
          </p>
        </div>
      </div>

      <!-- Экран приемки заказов -->
      <div class="panel">
        <div class="title">📦 Прием заказов</div>
        <div class="reception" id="reception">
          <div class="client-queue" id="clientQueue">
            <div class="patience-meter" id="patienceMeter">
              <div class="patience-progress" id="patienceProgress"></div>
            </div>
          </div>
        </div>
        <div class="delivery-slot" id="deliverySlot">
          <div class="delivery-label">Зона выдачи</div>
        </div>
      </div>

      <!-- Склад -->
      <div class="panel">
        <div class="title">🏭 Склад</div>
        <div class="warehouse-container">
          <div class="warehouse" id="warehouse"></div>
        </div>
      </div>
    </div>

    <script>
      // Инициализация Telegram WebApp
      Telegram.WebApp.expand();
      Telegram.WebApp.enableClosingConfirmation();

      // Игровые переменные
      let score = 0;
      let timeLeft = 60;
      let level = 1;
      let gameActive = false;
      let timer;
      let orders = [];
      let draggedPackage = null;
      let isOverDeliverySlot = false;
      let warehouseColumns = 5;
      let warehouseRows = 5;
      let clientQueue = [];
      const maxQueueLength = 5;
      const clientSpawnChance = 0.5;
      const minSpawnDelay = 1000;
      const maxSpawnDelay = 1500;
      let patienceTimer;
      const patienceTime = 15;

      // DOM элементы
      const warehouseEl = document.getElementById("warehouse");
      const scoreEl = document.getElementById("score");
      const timeEl = document.getElementById("time");
      const levelEl = document.getElementById("level");
      const helpBtn = document.getElementById("helpBtn");
      const helpModal = document.getElementById("helpModal");
      const closeHelpBtn = document.getElementById("closeHelpBtn");
      const deliverySlot = document.getElementById("deliverySlot");
      const patienceMeter = document.getElementById("patienceMeter");
      const patienceProgress = document.getElementById("patienceProgress");
      const clientQueueEl = document.getElementById("clientQueue");

      // Инициализация игры
      function initGame() {
        createWarehouse();
        generateOrders();
        setupDragAndDrop();
        startGame();

        helpBtn.addEventListener(
          "click",
          () => (helpModal.style.display = "flex")
        );
        closeHelpBtn.addEventListener(
          "click",
          () => (helpModal.style.display = "none")
        );
        helpModal.addEventListener("click", (e) => {
          if (e.target === helpModal) helpModal.style.display = "none";
        });
      }

      // Создание склада
      function createWarehouse() {
        warehouseEl.innerHTML = "";
        warehouseEl.style.gridTemplateColumns = `repeat(${warehouseColumns}, 1fr)`;

        for (let i = 0; i < warehouseColumns * warehouseRows; i++) {
          const shelf = document.createElement("div");
          shelf.className = "shelf";
          shelf.dataset.index = i;
          warehouseEl.appendChild(shelf);
        }
      }

      // Увеличение склада
      function expandWarehouse() {
        if (level % 2 === 0) {
          warehouseColumns = Math.min(10, warehouseColumns + 1);
          warehouseRows = Math.min(10, warehouseRows + 1);
          createWarehouse();
        }
      }

      // Генерация заказов
      function generateOrders(count = null) {
        if (!count) count = Math.min(5 + Math.floor(level / 2), 10);

        // Сначала очистим несуществующие заказы
        orders = orders.filter((order) =>
          document.querySelector(`.package[data-order-id="${order.id}"]`)
        );

        // Создаем массив доступных позиций на складе
        const availablePositions = [];
        const shelves = document.querySelectorAll(".shelf");
        shelves.forEach((shelf, index) => {
          if (index >= 5 && !shelf.querySelector(".package")) {
            availablePositions.push(index);
          }
        });

        // Генерируем новые уникальные заказы
        const newOrders = [];
        while (newOrders.length < count && availablePositions.length > 0) {
          const letter = String.fromCharCode(
            65 + Math.floor(Math.random() * 5)
          );
          const number = Math.floor(100 + Math.random() * 900);
          const orderId = `${letter}-${number}`;

          // Проверяем, что такого заказа еще нет
          if (!orders.some((o) => o.id === orderId)) {
            const posIndex = Math.floor(
              Math.random() * availablePositions.length
            );
            const position = availablePositions[posIndex];
            availablePositions.splice(posIndex, 1);

            newOrders.push({
              id: orderId,
              position: position,
              element: null,
            });
          }
        }

        orders = orders.concat(newOrders);
        placeOrdersOnWarehouse();
      }

      function findAvailableShelfPosition() {
        const shelves = document.querySelectorAll(".shelf");
        const availablePositions = [];

        shelves.forEach((shelf, index) => {
          if (index >= 5 && !shelf.querySelector(".package")) {
            availablePositions.push(index);
          }
        });

        return availablePositions.length > 0
          ? availablePositions[
              Math.floor(Math.random() * availablePositions.length)
            ]
          : -1;
      }
      // Размещение заказов на складе
      function placeOrdersOnWarehouse() {
        const shelves = document.querySelectorAll(".shelf");

        shelves.forEach((shelf, index) => {
          if (index >= 5) {
            const existingPackage = shelf.querySelector(".package");
            if (existingPackage) shelf.removeChild(existingPackage);
          }
        });

        orders.forEach((order) => {
          const shelf = document.querySelector(
            `.shelf[data-index="${order.position}"]`
          );
          if (shelf && !shelf.querySelector(".package")) {
            const packageEl = document.createElement("div");
            packageEl.className = "package";
            packageEl.textContent = order.id;
            packageEl.dataset.orderId = order.id;

            const colors = ["beige", "brown", "gray", "purple"];
            packageEl.classList.add(
              colors[Math.floor(Math.random() * colors.length)]
            );

            shelf.appendChild(packageEl);
            order.element = packageEl;
          }
        });
      }

      // Управление очередью клиентов
      function startClientCycle() {
        if (!gameActive) return;

        // Увеличиваем шанс появления новых клиентов
        if (
          clientQueue.length < maxQueueLength &&
          Math.random() > 1 - clientSpawnChance
        ) {
          addClientToQueue();
        }

        // Уменьшаем задержку между появлениями клиентов
        const delay =
          clientQueue.length === 0
            ? minSpawnDelay
            : minSpawnDelay + Math.random() * (maxSpawnDelay - minSpawnDelay);

        setTimeout(startClientCycle, delay);
        updatePatienceForAllClients();
      }
      function addClientToQueue() {
        // Получаем только заказы, которые реально есть на складе
        const availableOrders = orders.filter((order) => {
          const packageExists = !!document.querySelector(
            `.package[data-order-id="${order.id}"]`
          );
          const alreadyInQueue = clientQueue.some(
            (client) => client.order.id === order.id
          );
          return packageExists && !alreadyInQueue;
        });

        if (availableOrders.length === 0) {
          // Если нет доступных заказов - генерируем новые
          generateOrders();
          setTimeout(addClientToQueue, 500);
          return;
        }

        // Выбираем случайный доступный заказ
        const randomOrder =
          availableOrders[Math.floor(Math.random() * availableOrders.length)];

        const client = {
          id: Date.now(),
          order: randomOrder,
          patience: patienceTime,
          element: null,
          meter: null,
        };

        clientQueue.push(client);
        renderClientQueue();

        if (clientQueue.length === 1) {
          startPatienceTimer();
        }
      }
      function renderClientQueue() {
        clientQueueEl.innerHTML = "";

        const clientWidth = 70; // Ширина одного клиента с отступами
        const startOffset = 20; // Начальный отступ

        clientQueue.forEach((client, index) => {
          const packageExists = !!document.querySelector(
            `.package[data-order-id="${client.order.id}"]`
          );
          if (!packageExists) {
            // Если заказ исчез - удаляем клиента
            clientQueue.splice(index, 1);
            return;
          }
          const clientContainer = document.createElement("div");
          clientContainer.className = "client-container";
          clientContainer.style.left = `${startOffset + index * clientWidth}px`;

          // Полоска терпения
          const patienceMeter = document.createElement("div");
          patienceMeter.className = "patience-meter";
          patienceMeter.innerHTML = `
            <div class="patience-progress" 
                 style="width:${(client.patience / patienceTime) * 100}%">
            </div>`;

          // Иконка клиента
          const clientIcon = document.createElement("div");
          clientIcon.className = "client neutral";
          clientIcon.dataset.clientId = client.id;

          // Информация о заказе
          const orderInfo = document.createElement("div");
          orderInfo.className = "order-info";
          orderInfo.textContent = client.order.id; // Короткий ID

          clientContainer.appendChild(patienceMeter);
          clientContainer.appendChild(clientIcon);
          clientContainer.appendChild(orderInfo);
          clientQueueEl.appendChild(clientContainer);

          client.element = clientIcon;
          client.meter = patienceMeter.querySelector(".patience-progress");
        });
      }
      function updatePatienceForAllClients() {
        clientQueue.forEach((client, index) => {
          if (client.meter) {
            const percent = (client.patience / patienceTime) * 100;
            client.meter.style.width = `${percent}%`;

            if (percent < 30) {
              client.meter.style.backgroundColor = "#d9534f";
            } else if (percent < 60) {
              client.meter.style.backgroundColor = "#f0ad4e";
            } else {
              client.meter.style.backgroundColor = "#5cb85c";
            }
          }
        });
      }

      function startPatienceTimer() {
        clearInterval(patienceTimer);
        patienceMeter.style.display = "block";
        patienceTimer = setInterval(() => {
          if (clientQueue.length === 0) {
            clearInterval(patienceTimer);
            return;
          }

          const currentClient = clientQueue[0];
          currentClient.patience--;
          if (currentClient.patience <= 0) {
            if (currentClient.element) {
              currentClient.element.classList.remove("happy", "neutral");
              currentClient.element.classList.add("angry");
            }

            setTimeout(() => {
              clientQueue.shift();
              renderClientQueue();

              if (currentClient.element && currentClient.element.parentNode) {
                currentClient.element.style.left = "-60px";
                setTimeout(() => {
                  if (
                    currentClient.element &&
                    currentClient.element.parentNode
                  ) {
                    currentClient.element.parentNode.removeChild(
                      currentClient.element
                    );
                  }
                }, 500);
              }

              if (clientQueue.length > 0) {
                startPatienceTimer();
              } else {
                patienceMeter.style.display = "none";
                setTimeout(startClientCycle, 1000 + Math.random() * 2000);
              }
            }, 500);
          } else {
            updatePatienceForAllClients();
          }
        }, 1000);
      }

      // Обработка успешной доставки
      function handleSuccessfulDelivery(order) {
        if (clientQueue.length === 0) return;

        const currentClient = clientQueue[0];
        orders = orders.filter((o) => o.id !== order.id);

        const packageEl = document.querySelector(
          `.package[data-order-id="${order.id}"]`
        );
        if (packageEl && packageEl.parentNode) {
          packageEl.parentNode.removeChild(packageEl);
        }

        const speedBonus = Math.floor(
          (currentClient.patience / patienceTime) * 5
        );
        score += (10 + speedBonus) * level;
        scoreEl.textContent = score;

        if (currentClient.element) {
          currentClient.element.classList.add("happy");
          // Добавляем анимацию перед удалением
          setTimeout(() => {
            currentClient.element.style.left = "100%"; // Плавно уходит вправо
            setTimeout(() => {
              if (currentClient.element && currentClient.element.parentNode) {
                currentClient.element.parentNode.removeChild(
                  currentClient.element
                );
              }
            }, 500);
          }, 1000); // Даем время на анимацию happy
        }

        // Удаляем клиента из очереди после анимации
        setTimeout(() => {
          clientQueue.shift();
          renderClientQueue();

          if (clientQueue.length > 0) {
            startPatienceTimer();
          } else {
            patienceMeter.style.display = "none";
            startClientCycle();
          }
        }, 1500); // Увеличили время до удаления

        if (score >= level * 50) {
          level++;
          levelEl.textContent = level;
          timeLeft += 10;
          timeEl.textContent = timeLeft;
          expandWarehouse();

          if (level % 2 === 0) {
            generateOrders(Math.floor(level / 2) + 2);
          }
        }
      }
      // Drag and Drop
      function setupDragAndDrop() {
        let startX, startY;

        document.addEventListener("mousedown", startDrag);
        document.addEventListener("touchstart", startDrag, { passive: false });
        document.addEventListener("mousemove", dragPackage);
        document.addEventListener("touchmove", dragPackage, { passive: false });
        document.addEventListener("mouseup", endDrag);
        document.addEventListener("touchend", endDrag);

        deliverySlot.addEventListener("dragover", (e) => {
          e.preventDefault();
          isOverDeliverySlot = true;
          deliverySlot.classList.add("active");
        });

        deliverySlot.addEventListener("dragleave", () => {
          isOverDeliverySlot = false;
          deliverySlot.classList.remove("active");
        });

        function startDrag(e) {
          if (!gameActive) return;

          const packageEl = e.target.closest(".package");
          if (!packageEl) return;

          if (e.type === "touchstart") {
            e.preventDefault();
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
          } else {
            startX = e.clientX;
            startY = e.clientY;
          }

          draggedPackage = packageEl;
          packageEl.classList.add("active");
          packageEl.style.position = "absolute";
          packageEl.style.zIndex = "1000";
          updatePackagePosition(e);
        }

        function dragPackage(e) {
          if (!draggedPackage) return;

          if (e.type === "touchmove") {
            e.preventDefault();
            const touch = e.touches[0];
            updatePackagePosition({
              clientX: touch.clientX,
              clientY: touch.clientY,
            });
          } else {
            updatePackagePosition(e);
          }

          const rect = deliverySlot.getBoundingClientRect();
          const clientX =
            e.type === "touchmove" ? e.touches[0].clientX : e.clientX;
          const clientY =
            e.type === "touchmove" ? e.touches[0].clientY : e.clientY;

          if (
            clientX >= rect.left &&
            clientX <= rect.right &&
            clientY >= rect.top &&
            clientY <= rect.bottom
          ) {
            if (!isOverDeliverySlot) {
              isOverDeliverySlot = true;
              deliverySlot.classList.add("active");
            }
          } else {
            if (isOverDeliverySlot) {
              isOverDeliverySlot = false;
              deliverySlot.classList.remove("active");
            }
          }
        }

        function updatePackagePosition(e) {
          if (!draggedPackage) return;

          const rect = document
            .querySelector(".reception")
            .getBoundingClientRect();
          const x = e.clientX - rect.left - draggedPackage.offsetWidth / 2;
          const y = e.clientY - rect.top - draggedPackage.offsetHeight / 2;

          draggedPackage.style.left = `${x}px`;
          draggedPackage.style.top = `${y}px`;
        }

        function endDrag(e) {
          if (!draggedPackage) return;

          let clientX, clientY;
          if (e.type === "touchend") {
            const touch = e.changedTouches[0];
            clientX = touch.clientX;
            clientY = touch.clientY;
          } else {
            clientX = e.clientX;
            clientY = e.clientY;
          }

          // Проверка зоны выдачи
          const deliveryRect = deliverySlot.getBoundingClientRect();
          if (
            clientX >= deliveryRect.left &&
            clientX <= deliveryRect.right &&
            clientY >= deliveryRect.top &&
            clientY <= deliveryRect.bottom
          ) {
            const orderId = draggedPackage.dataset.orderId;
            if (clientQueue.length > 0 && orderId === clientQueue[0].order.id) {
              const order = orders.find((o) => o.id === orderId);
              if (order) handleSuccessfulDelivery(order);
            } else {
              score = Math.max(0, score - 5);
              scoreEl.textContent = score;
              if (clientQueue.length > 0 && clientQueue[0].element) {
                clientQueue[0].element.classList.add("angry");
                setTimeout(() => {
                  if (clientQueue[0] && clientQueue[0].element) {
                    clientQueue[0].element.classList.remove("angry");
                  }
                }, 1000);
              }
            }
          } else {
            // Проверка перемещения на другую полку
            const shelves = document.querySelectorAll(".shelf");
            let targetShelf = null;

            shelves.forEach((shelf) => {
              const rect = shelf.getBoundingClientRect();
              if (
                clientX >= rect.left &&
                clientX <= rect.right &&
                clientY >= rect.top &&
                clientY <= rect.bottom &&
                !shelf.querySelector(".package")
              ) {
                targetShelf = shelf;
              }
            });

            if (targetShelf) {
              targetShelf.appendChild(draggedPackage);
              const orderId = draggedPackage.dataset.orderId;
              const order = orders.find((o) => o.id === orderId);
              if (order) order.position = parseInt(targetShelf.dataset.index);
            }
          }

          // Сброс состояния
          draggedPackage.classList.remove("active");
          draggedPackage.style.position = "";
          draggedPackage.style.zIndex = "";
          draggedPackage.style.left = "";
          draggedPackage.style.top = "";
          draggedPackage = null;
          isOverDeliverySlot = false;
          deliverySlot.classList.remove("active");
        }
      }

      // Управление игрой
      function startGame() {
        score = 0;
        timeLeft = 60;
        level = 1;
        warehouseColumns = 5;
        warehouseRows = 5;
        clientQueue = [];
        orders = [];

        scoreEl.textContent = score;
        timeEl.textContent = timeLeft;
        levelEl.textContent = level;
        gameActive = true;

        clearInterval(timer);
        timer = setInterval(() => {
          timeLeft--;
          timeEl.textContent = timeLeft;

          if (timeLeft <= 0) endGame();
        }, 1000);

        startClientCycle();
      }

      function endGame() {
        gameActive = false;
        clearInterval(timer);
        alert(`Игра окончена! Ваш счет: ${score}`);

        if (Telegram.WebApp.initDataUnsafe?.user) {
          const userId = Telegram.WebApp.initDataUnsafe.user.id;
          // Отправка результатов на сервер
        }
      }

      window.addEventListener("load", initGame);
    </script>
  </body>
</html>
